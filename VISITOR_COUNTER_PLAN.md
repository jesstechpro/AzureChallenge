# Visitor Counter Implementation Plan - Phased Approach

## Architecture Overview
```
[User's Browser] → [Static Website] → [Azure Function API] → [Cosmos DB]
    ↑                                         ↑
    └─────────────────────────────────────────┘
          (AJAX call to increment counter)
```

# Phase 1: Local Development Setup (Completed)
1. **Install Prerequisites (Completed)**
   - [x] Install Python 3.12 (verify with `py --version`)
   - [x] Install Node.js (includes npm) (verify with `node --version` and `npm --version`)
   - [x] Install Azure Functions Core Tools v4
   - [x] Install VS Code with Azure Functions extension (verify with `code --version`)
   - [x] Install Azure CLI (verify with `az --version`)

   Notes:
   - On Windows, PowerShell may block the npm-installed `func.ps1` shim (execution policy). Use `func.cmd` instead.
   - We used `func.cmd --version` to verify Functions Core Tools.

2. **Initialize Project Structure (Completed)**
   ```bash
   mkdir VisitorCounter
   cd VisitorCounter
   func.cmd init --python
   ```
   Generated files:
   - [x] `requirements.txt`
   - [x] `function_app.py`
   - [x] `.gitignore`
   - [x] `host.json`
   - [x] `local.settings.json`
   - [x] `.vscode/extensions.json`

# Phase 2: Backend Development (Completed)
1. **Create Azure Functions (Completed)**
   Using the v2 Python programming model (decorators in `function_app.py`):
   - [x] `get_counter` - GET /api/counter
   - [x] `increment_counter` - POST /api/counter/increment

2. **Set Up Local Settings (Completed)**
   - [x] `local.settings.json` auto-generated by `func init`
   - [ ] Cosmos DB connection string (deferred to Phase 3)

3. **Implement Get Counter Function (Completed)**
   - [x] Endpoint: `GET /api/counter`
   - [x] Returns: `{ "count": <value> }`

4. **Implement Increment Counter Function (Completed)**
   - [x] Endpoint: `POST /api/counter/increment`
   - [x] Returns: `{ "count": <new_value> }`

5. **Local Testing (Completed)**
   - [x] Started local server with `func.cmd start`
   - [x] Tested GET /api/counter → `{"count": 0}`
   - [x] Tested POST /api/counter/increment → `{"count": 1}`
   - [x] Verified counter persists in memory

   Note: Currently using in-memory store; will connect to Cosmos DB in Phase 3.

# Phase 3: Database Setup (Completed)
1. **Cosmos DB Resources (Already provisioned in Azure)**
   - [x] Database: `VisitorCounterDb`
   - [x] Container: `Counters`
   - [x] Partition Key: `/_partitionKey`
   - Note: Existing Cosmos DB account `visitorcounterwebdb` already contains the `Counters` container with initial document (see screenshot).

2. **Application Configuration (Completed)**
   - [x] Added `COSMOSDB_CONNECTION_STRING` (+ helper values) to `local.settings.json`
   - [x] Installed `azure-cosmos` SDK (`requirements.txt`)

3. **Function Updates (Completed)**
   - [x] `get_counter` now reads from Cosmos DB (ensures doc exists, normalizes count)
   - [x] `increment_counter` increments and persists back to Cosmos DB

4. **Local Testing (Completed)**
   - [x] `func.cmd start` with Cosmos DB connection
   - [x] `GET /api/counter` returns stored count (`{"count": 0}` initially)
   - [x] `POST /api/counter/increment` updates DB (`{"count": 1}`) and persists

5. **Initial Document**
   ```json
   {
     "id": "1",
     "count": 0,
     "_partitionKey": "1"
   }
   ```

# Phase 4: Frontend Development
1. **Create Static Website**
   - `index.html` - Basic structure
   - `style.css` - Simple styling
   - `script.js` - Counter logic

2. **Implement Features**
   - Display current counter
   - Manual increment button
   - Auto-increment on page load
   - Error handling

# Phase 5: Local Testing
1. **Backend Testing**
   - Test functions locally with `func start`
   - Use Postman/curl for API testing
   - Verify Cosmos DB integration

2. **Frontend Testing**
   - Test with local Function endpoints
   - Verify counter updates
   - Test error cases

# Phase 6: Azure Deployment
1. **Deploy Azure Resources**
   - Create Resource Group
   - Deploy Azure Functions
   - Set up Cosmos DB
   - Configure CORS

2. **Deploy Frontend**
   - Deploy to Azure Storage Static Website
   - Update API endpoints
   - Test in production

# Phase 7: Monitoring & Maintenance
1. **Set Up Monitoring**
   - Application Insights
   - Logging
   - Alerting

2. **Security Review**
   - Verify CORS settings
   - Check function authorization
   - Secure connection strings

## Implementation Notes
- Each phase should be completed and tested before moving to the next
- Version control should be used throughout
- Document any issues or decisions made during implementation
